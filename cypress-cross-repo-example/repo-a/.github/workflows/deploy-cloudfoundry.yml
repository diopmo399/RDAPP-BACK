name: Deploy to Cloud Foundry

on:
  workflow_dispatch:
    inputs:
      environment:
        description: 'Target environment'
        required: true
        type: choice
        options:
          - staging
          - preprod
        default: staging
      ref:
        description: 'Git ref to deploy (branch/tag/SHA)'
        required: false
        type: string
        default: main
      triggered_by_repo:
        description: 'Repository that triggered this deployment'
        required: false
        type: string
  schedule:
    # D√©ploiement automatique quotidien
    # Format: minute hour day month day-of-week (UTC)
    # Exemples:
    # - cron: '0 2 * * *'      # Tous les jours √† 2h00 UTC
    # - cron: '0 8 * * 1-5'    # Du lundi au vendredi √† 8h00 UTC
    # - cron: '30 14 * * 1'    # Tous les lundis √† 14h30 UTC
    - cron: '0 6 * * 1-5'      # Du lundi au vendredi √† 6h00 UTC (d√©ploiement staging)

env:
  NODE_VERSION: '18'
  CF_CLI_VERSION: '8'

# Concurrency: annuler les d√©ploiements pr√©c√©dents pour le m√™me environnement
concurrency:
  group: deploy-cf-${{ github.event.inputs.environment || 'staging' }}
  cancel-in-progress: true

jobs:
  deploy:
    name: Deploy to Cloud Foundry
    runs-on: ubuntu-latest

    permissions:
      contents: read
      actions: write

    outputs:
      deployment-url: ${{ steps.get-route.outputs.base-url }}
      app-name: ${{ steps.determine-app.outputs.app-name }}
      environment: ${{ steps.determine-app.outputs.environment }}
      deployment-status: ${{ steps.deploy.outputs.status }}

    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        with:
          ref: ${{ github.event.inputs.ref || 'main' }}

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: ${{ env.NODE_VERSION }}
          cache: 'npm'

      - name: Display deployment info
        run: |
          echo "::notice::Deploying to Cloud Foundry"

          # Afficher l'environnement selon le type de d√©clenchement
          if [ "${{ github.event_name }}" = "schedule" ]; then
            echo "::notice::Trigger: Scheduled (cron)"
            echo "::notice::Environment: staging (automatic)"
            echo "::notice::Ref: main"
          else
            echo "::notice::Trigger: Manual (workflow_dispatch)"
            echo "::notice::Environment: ${{ github.event.inputs.environment }}"
            echo "::notice::Ref: ${{ github.event.inputs.ref || 'main' }}"
            echo "::notice::Triggered by: ${{ github.event.inputs.triggered_by_repo || 'manual' }}"
          fi

          echo "Run ID: ${{ github.run_id }}"
          echo "Run Number: ${{ github.run_number }}"

      - name: Install dependencies
        run: npm ci

      - name: Build application
        run: |
          echo "Building application..."
          npm run build

          echo "::notice::Build completed successfully"

      - name: Install Cloud Foundry CLI
        run: |
          wget -q -O - https://packages.cloudfoundry.org/debian/cli.cloudfoundry.org.key | sudo apt-key add -
          echo "deb https://packages.cloudfoundry.org/debian stable main" | sudo tee /etc/apt/sources.list.d/cloudfoundry-cli.list
          sudo apt-get update
          sudo apt-get install cf${{ env.CF_CLI_VERSION }}-cli

          cf --version
          echo "::notice::Cloud Foundry CLI installed"

      - name: Determine application name
        id: determine-app
        run: |
          # D√©terminer l'environnement selon le type de d√©clenchement
          if [ "${{ github.event_name }}" = "schedule" ]; then
            # D√©ploiement automatique (scheduler) ‚Üí toujours staging
            ENVIRONMENT="staging"
            echo "::notice::Scheduler deployment ‚Üí Environment: staging"
          else
            # D√©ploiement manuel (workflow_dispatch) ou API
            ENVIRONMENT="${{ github.event.inputs.environment }}"
          fi

          # Si ENVIRONMENT est vide (cas improbable), fallback √† staging
          if [ -z "$ENVIRONMENT" ]; then
            ENVIRONMENT="staging"
            echo "::warning::Environment not set, defaulting to staging"
          fi

          case "$ENVIRONMENT" in
            staging)
              APP_NAME="${{ secrets.CF_APP_NAME_STAGING }}"
              ;;
            preprod)
              APP_NAME="${{ secrets.CF_APP_NAME_PREPROD }}"
              ;;
            *)
              echo "::error::Unknown environment: $ENVIRONMENT"
              exit 1
              ;;
          esac

          if [ -z "$APP_NAME" ]; then
            echo "::error::CF_APP_NAME not configured for environment: $ENVIRONMENT"
            exit 1
          fi

          echo "app-name=${APP_NAME}" >> $GITHUB_OUTPUT
          echo "environment=${ENVIRONMENT}" >> $GITHUB_OUTPUT
          echo "::notice::Environment: ${ENVIRONMENT}"
          echo "::notice::Application name: ${APP_NAME}"

      - name: Authenticate to Cloud Foundry
        env:
          CF_API: ${{ secrets.CF_API }}
          CF_USERNAME: ${{ secrets.CF_USERNAME }}
          CF_PASSWORD: ${{ secrets.CF_PASSWORD }}
          CF_ORG: ${{ secrets.CF_ORG }}
          CF_SPACE: ${{ secrets.CF_SPACE }}
          CF_SKIP_SSL: ${{ secrets.CF_SKIP_SSL_VALIDATION || 'false' }}
        run: |
          echo "Connecting to Cloud Foundry..."

          # Set API endpoint
          if [ "$CF_SKIP_SSL" = "true" ]; then
            cf api "$CF_API" --skip-ssl-validation
          else
            cf api "$CF_API"
          fi

          # Authenticate
          cf auth "$CF_USERNAME" "$CF_PASSWORD"

          # Target org and space
          cf target -o "$CF_ORG" -s "$CF_SPACE"

          echo "::notice::‚úÖ Authenticated to Cloud Foundry"
          echo "::notice::Org: $CF_ORG"
          echo "::notice::Space: $CF_SPACE"

      - name: Deploy application to Cloud Foundry
        id: deploy
        env:
          APP_NAME: ${{ steps.determine-app.outputs.app-name }}
        run: |
          echo "Deploying application: $APP_NAME"

          # Push application (uses manifest.yml if present)
          cf push "$APP_NAME" -f manifest.yml

          if [ $? -eq 0 ]; then
            echo "status=success" >> $GITHUB_OUTPUT
            echo "::notice::‚úÖ Application deployed successfully"
          else
            echo "status=failed" >> $GITHUB_OUTPUT
            echo "::error::‚ùå Deployment failed"
            exit 1
          fi

      - name: Get application route
        id: get-route
        env:
          APP_NAME: ${{ steps.determine-app.outputs.app-name }}
        run: |
          echo "Retrieving application route..."

          # Get app info and extract route
          APP_INFO=$(cf app "$APP_NAME")

          # Extract route (first route listed)
          ROUTE=$(echo "$APP_INFO" | grep -i "routes:" -A 1 | tail -1 | xargs)

          if [ -z "$ROUTE" ]; then
            echo "::error::Could not retrieve application route"
            exit 1
          fi

          # Construct base URL
          BASE_URL="https://${ROUTE}"

          echo "base-url=${BASE_URL}" >> $GITHUB_OUTPUT
          echo "::notice::Application URL: ${BASE_URL}"

      - name: Health check
        id: healthcheck
        env:
          BASE_URL: ${{ steps.get-route.outputs.base-url }}
        run: |
          MAX_ATTEMPTS=60
          SLEEP_TIME=5

          echo "Waiting for application to be ready at ${BASE_URL}..."

          for i in $(seq 1 $MAX_ATTEMPTS); do
            echo "Health check attempt $i/$MAX_ATTEMPTS..."

            # Try to reach the application
            HTTP_CODE=$(curl -k -s -o /dev/null -w "%{http_code}" "${BASE_URL}" || echo "000")

            if [[ "$HTTP_CODE" =~ ^(200|301|302|304)$ ]]; then
              echo "::notice::‚úÖ Application is ready! (HTTP $HTTP_CODE)"
              echo "ready=true" >> $GITHUB_OUTPUT
              exit 0
            fi

            echo "Not ready yet (HTTP $HTTP_CODE), waiting ${SLEEP_TIME}s..."
            sleep $SLEEP_TIME
          done

          echo "::error::‚ùå Application health check failed after ${MAX_ATTEMPTS} attempts"
          echo "ready=false" >> $GITHUB_OUTPUT
          exit 1

      - name: Create deployment artifact
        env:
          BASE_URL: ${{ steps.get-route.outputs.base-url }}
          APP_NAME: ${{ steps.determine-app.outputs.app-name }}
          ENVIRONMENT: ${{ steps.determine-app.outputs.environment }}
          REF: ${{ github.event.inputs.ref || 'main' }}
        run: |
          mkdir -p target

          # D√©terminer le triggeredBy
          if [ "${{ github.event_name }}" = "schedule" ]; then
            TRIGGERED_BY="scheduler"
          else
            TRIGGERED_BY="${{ github.event.inputs.triggered_by_repo || 'manual' }}"
          fi

          cat > target/deployment.json <<EOF
          {
            "baseUrl": "${BASE_URL}",
            "appName": "${APP_NAME}",
            "environment": "${ENVIRONMENT}",
            "ref": "${REF}",
            "deployedAt": "$(date -u +%Y-%m-%dT%H:%M:%SZ)",
            "runId": "${{ github.run_id }}",
            "runNumber": "${{ github.run_number }}",
            "triggeredBy": "${TRIGGERED_BY}",
            "cfOrg": "${{ secrets.CF_ORG }}",
            "cfSpace": "${{ secrets.CF_SPACE }}"
          }
          EOF

          echo "::notice::Deployment artifact created"
          cat target/deployment.json

      - name: Upload deployment artifact
        uses: actions/upload-artifact@v4
        with:
          name: deployment-info-${{ github.run_id }}
          path: target/deployment.json
          retention-days: 7

      - name: Deployment summary
        run: |
          # D√©terminer le trigger
          if [ "${{ github.event_name }}" = "schedule" ]; then
            TRIGGER="‚è∞ Scheduled (cron)"
          else
            TRIGGER="üñ±Ô∏è  Manual (workflow_dispatch)"
          fi

          echo "## üöÄ Cloud Foundry Deployment Successful" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "**Trigger:** ${TRIGGER}" >> $GITHUB_STEP_SUMMARY
          echo "**Environment:** ${{ steps.determine-app.outputs.environment }}" >> $GITHUB_STEP_SUMMARY
          echo "**Application:** ${{ steps.determine-app.outputs.app-name }}" >> $GITHUB_STEP_SUMMARY
          echo "**URL:** ${{ steps.get-route.outputs.base-url }}" >> $GITHUB_STEP_SUMMARY
          echo "**Ref:** ${{ github.event.inputs.ref || 'main' }}" >> $GITHUB_STEP_SUMMARY
          echo "**Status:** ${{ steps.deploy.outputs.status }}" >> $GITHUB_STEP_SUMMARY
          echo "**Health Check:** ${{ steps.healthcheck.outputs.ready }}" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "**Artifact:** deployment-info-${{ github.run_id }}" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "**Cloud Foundry:**" >> $GITHUB_STEP_SUMMARY
          echo "- Org: ${{ secrets.CF_ORG }}" >> $GITHUB_STEP_SUMMARY
          echo "- Space: ${{ secrets.CF_SPACE }}" >> $GITHUB_STEP_SUMMARY

  notify:
    name: Notify deployment status
    runs-on: ubuntu-latest
    needs: deploy
    if: always()

    steps:
      - name: Deployment status
        run: |
          ENVIRONMENT="${{ needs.deploy.outputs.environment }}"

          if [ "${{ needs.deploy.result }}" = "success" ]; then
            echo "::notice::‚úÖ Deployment to ${ENVIRONMENT} succeeded"
            echo "::notice::URL: ${{ needs.deploy.outputs.deployment-url }}"
          else
            echo "::error::‚ùå Deployment to ${ENVIRONMENT} failed"
            exit 1
          fi
